/*
  Smart Space Control - ESP8266 Firmware
  Author: Generated by Antigravity
  
  Description:
  This code connects an ESP8266 to WiFi and polls a ThingSpeak channel for commands.
  It controls 8 
  outputs (Fans and Lights) based on Fields 1-8 of the ThingSpeak channel.
  
  Hardware:
  - ESP8266 NodeMCU (or similar)
  - 8-Channel Relay Module (Active LOW assumed, change RELAY_ON if needed)
  
  ThingSpeak Mapping:
  - Field 1 -> Fan 1 -> Pin D0
  - Field 2 -> Fan 2 -> Pin D1
  - Field 3 -> Fan 3 -> Pin D2
  - Field 4 -> Fan 4 -> Pin D3
  - Field 5 -> Light 1 -> Pin D4
  - Field 6 -> Light 2 -> Pin D5
  - Field 7 -> Light 3 -> Pin D6
  - Field 8 -> Light 4 -> Pin D7
*/

#include <ESP8266WiFi.h>
#include "ThingSpeak.h"

// --------------------------------------------------------------------------------
//  CONFIGURATION SECTION - EDIT THESE VALUES
// --------------------------------------------------------------------------------

// WiFi Credentials
const char* ssid = "YOUR_WIFI_SSID";
const char* password = "YOUR_WIFI_PASSWORD";

// ThingSpeak Channel Settings
unsigned long channelID = 3250252;        // Default: Set 1 Channel ID
const char* readAPIKey = "YZMUKLWR4D67NZZU";  // Default: Set 1 Read Key

// --------------------------------------------------------------------------------
//  PIN MAPPING
// --------------------------------------------------------------------------------

// Map ThingSpeak Fields (1-8) to NodeMCU Pins (D0-D7)
/* 
   Note on NodeMCU Pins:
   D0 = GPIO16
   D1 = GPIO5
   D2 = GPIO4
   D3 = GPIO0  (Flash Button)
   D4 = GPIO2  (Built-in LED)
   D5 = GPIO14
   D6 = GPIO12
   D7 = GPIO13
*/
const int outputPins[8] = {D0, D1, D2, D3, D4, D5, D6, D7};

// Relay Logic Configuration
// Most relay modules are Active LOW (LOW = ON, HIGH = OFF).
// If your relay is Active HIGH (HIGH = ON, LOW = OFF), swap these values.
const int RELAY_ON = LOW;
const int RELAY_OFF = HIGH;

// --------------------------------------------------------------------------------
//  GLOBALS
// --------------------------------------------------------------------------------

WiFiClient client;
unsigned long lastTime = 0;
const unsigned long timerDelay = 5000; // Poll every 5 seconds (ThingSpeak Limit ~15s for free, fast for paid)

void setup() {
  Serial.begin(115200);
  
  // Initialize Pins
  for (int i = 0; i < 8; i++) {
    pinMode(outputPins[i], OUTPUT);
    digitalWrite(outputPins[i], RELAY_OFF); // Start with everything OFF
  }

  // Connect to WiFi
  WiFi.mode(WIFI_STA);
  ThingSpeak.begin(client);
  
  connectWiFi();
}

void loop() {
  // Ensure WiFi connection
  if (WiFi.status() != WL_CONNECTED) {
    connectWiFi();
  }

  // Periodic Update
  if ((millis() - lastTime) > timerDelay) {
    readThingSpeak();
    lastTime = millis();
  }
}

void connectWiFi() {
  Serial.print("Connecting to WiFi: ");
  Serial.println(ssid);
  
  WiFi.begin(ssid, password);
  
  int timeout = 0;
  while (WiFi.status() != WL_CONNECTED && timeout < 20) {
    delay(500);
    Serial.print(".");
    timeout++;
  }
  
  if (WiFi.status() == WL_CONNECTED) {
    Serial.println("\nWiFi Connected.");
    Serial.print("IP Address: ");
    Serial.println(WiFi.localIP());
  } else {
    Serial.println("\nWiFi Connection Failed. Retrying in loop...");
  }
}

void readThingSpeak() {
  Serial.println("\nReading from ThingSpeak...");
  
  // Read multiple fields at once (Fields 1-8)
  // Note: ThingSpeak library doesn't support reading all fields in one call easily returning a struct,
  // but acts as a bridge. For efficiency, we read the last feed status.
  
  // Actually, easiest robust way with the library is individual integer reads or parsing the JSON status.
  // Using readMultipleFields would be ideal if supported fully, but standard readIntField is robust.
  // However, calling readIntField 8 times is slow and hits rate limits.
  // 
  // Better approach: Read the last feed for the channel which returns all fields.
  // The 'ThingSpeak' library simplifies this. We will use `readMultipleFields`.
  
  int statusCode = ThingSpeak.readMultipleFields(channelID, readAPIKey);
  
  if (statusCode == 200) {
    Serial.println("Data received successfully.");
    
    for (int i = 1; i <= 8; i++) {
      // Get field value (0 or 1)
      int value = ThingSpeak.getFieldAsInt(i);
      
      // Update Pin
      // Array index is i-1 (0-7)
      if (value == 1) {
        digitalWrite(outputPins[i-1], RELAY_ON);
        Serial.printf("Field %d: ON\n", i);
      } else {
        digitalWrite(outputPins[i-1], RELAY_OFF);
        Serial.printf("Field %d: OFF\n", i);
      }
    }
  } else {
    Serial.printf("Error reading ThingSpeak. Status: %d\n", statusCode);
  }
}
